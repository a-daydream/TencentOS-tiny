
use cty::*;
/* automatically generated by rust-bindgen 0.59.1 */

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k_err_en {
    K_ERR_NONE = 0,
    K_ERR_BARRIER_COUNT_INVALID = 5,
    K_ERR_BARRIER_OVERFLOW = 6,
    K_ERR_BITMAP_EXCEED = 10,
    K_ERR_BIN_HEAP_FULL = 15,
    K_ERR_BIN_HEAP_EMPTY = 16,
    K_ERR_BIN_HEAP_ITEM_SIZE_NOT_MATCH = 17,
    K_ERR_COMPLETION_OVERFLOW = 25,
    K_ERR_COUNTDOWNLATCH_OVERFLOW = 50,
    K_ERR_DELAY_ZERO = 100,
    K_ERR_DELAY_FOREVER = 101,
    K_ERR_EVENT_PEND_OPT_INVALID = 200,
    K_ERR_IN_IRQ = 400,
    K_ERR_KNL_NOT_RUNNING = 500,
    K_ERR_KNL_RUNNING = 501,
    K_ERR_LOCK_NESTING_OVERFLOW = 600,
    K_ERR_MMBLK_POOL_FULL = 700,
    K_ERR_MMBLK_POOL_EMPTY = 701,
    K_ERR_MMBLK_INVALID_BLK_SIZE = 702,
    K_ERR_MMBLK_INVALID_POOL_ADDR = 703,
    K_ERR_MMBLK_POOL_OUT_OF_MEMORY = 704,
    K_ERR_MMBLK_OUT_OF_MEMORY = 705,
    K_ERR_MMHEAP_INVALID_POOL_ADDR = 800,
    K_ERR_MMHEAP_INVALID_POOL_SIZE = 801,
    K_ERR_MMHEAP_POOL_OVERFLOW = 802,
    K_ERR_MMHEAP_POOL_ALREADY_EXIST = 803,
    K_ERR_MMHEAP_POOL_NOT_EXIST = 804,
    K_ERR_MUTEX_NOT_OWNER = 1000,
    K_ERR_MUTEX_NESTING = 1001,
    K_ERR_MUTEX_NESTING_OVERFLOW = 1002,
    K_ERR_OBJ_PTR_NULL = 1100,
    K_ERR_OBJ_INVALID = 1101,
    K_ERR_OBJ_INVALID_ALLOC_TYPE = 1102,
    K_ERR_OUT_OF_MEMORY = 1150,
    K_ERR_PEND_NOWAIT = 1200,
    K_ERR_PEND_SCHED_LOCKED = 1201,
    K_ERR_PEND_ABNORMAL = 1202,
    K_ERR_PEND_TIMEOUT = 1203,
    K_ERR_PEND_DESTROY = 1204,
    K_ERR_PEND_OWNER_DIE = 1205,
    K_ERR_PM_DEVICE_ALREADY_REG = 1300,
    K_ERR_PM_DEVICE_OVERFLOW = 1301,
    K_ERR_PM_WKUP_SOURCE_NOT_INSTALL = 1302,
    K_ERR_PRIO_Q_EMPTY = 1400,
    K_ERR_PRIO_Q_FULL = 1401,
    K_ERR_PRIO_Q_SLOT_NOT_TAKEN = 1402,
    K_ERR_PRIO_Q_ITEM_SIZE_NOT_MATCH = 1403,
    K_ERR_RING_Q_FULL = 1500,
    K_ERR_RING_Q_EMPTY = 1501,
    K_ERR_RING_Q_ITEM_SIZE_NOT_MATCH = 1502,
    K_ERR_RWLOCK_READERS_TO_MANY = 1600,
    K_ERR_RWLOCK_IS_READING = 1601,
    K_ERR_RWLOCK_IS_WRITTING = 1602,
    K_ERR_RWLOCK_NOT_READING = 1603,
    K_ERR_RWLOCK_NOT_WRITTING = 1604,
    K_ERR_RWLOCK_NOT_TAKEN = 1605,
    K_ERR_RWLOCK_WAITING_WRITERS_TO_MANY = 1606,
    K_ERR_SCHED_LOCKED = 1700,
    K_ERR_SCHED_NOT_LOCKED = 1701,
    K_ERR_SEM_OVERFLOW = 1800,
    K_ERR_TASK_ALREADY_CREATED = 1900,
    K_ERR_TASK_DESTROY_IDLE = 1901,
    K_ERR_TASK_NOT_DELAY = 1902,
    K_ERR_TASK_PRIO_INVALID = 1903,
    K_ERR_TASK_RESUME_SELF = 1904,
    K_ERR_TASK_SUSPENDED = 1905,
    K_ERR_TASK_SUSPEND_IDLE = 1906,
    K_ERR_TASK_STK_OVERFLOW = 1907,
    K_ERR_TASK_STK_SIZE_INVALID = 1908,
    K_ERR_TASK_OUT_OF_MEMORY = 1909,
    K_ERR_TICKLESS_WKUP_ALARM_NOT_INSTALLED = 2000,
    K_ERR_TICKLESS_WKUP_ALARM_NO_INIT = 2001,
    K_ERR_TICKLESS_WKUP_ALARM_INIT_FAILED = 2002,
    K_ERR_TIMER_INACTIVE = 2100,
    K_ERR_TIMER_DELAY_FOREVER = 2101,
    K_ERR_TIMER_PERIOD_FOREVER = 2102,
    K_ERR_TIMER_INVALID_DELAY = 2103,
    K_ERR_TIMER_INVALID_PERIOD = 2104,
    K_ERR_TIMER_INVALID_STATE = 2105,
    K_ERR_TIMER_INVALID_OPT = 2106,
    K_ERR_TIMER_STOPPED = 2107,
    K_ERR_TIMER_RUNNING = 2108,
    K_ERR_SEM_OUT_OF_MEMORY = 2200,
    K_ERR_MUTEX_OUT_OF_MEMORY = 2300,
}
pub use self::k_err_en as k_err_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum knl_obj_alloc_type_en {
    KNL_OBJ_ALLOC_TYPE_NONE = 0,
    KNL_OBJ_ALLOC_TYPE_STATIC = 1,
    KNL_OBJ_ALLOC_TYPE_DYNAMIC = 2,
}
pub use self::knl_obj_alloc_type_en as knl_obj_alloc_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct knl_object_st {
    pub alloc_type: knl_obj_alloc_type_t,
}
impl Default for knl_object_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type knl_obj_t = knl_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_list_node_st {
    pub next: *mut k_list_node_st,
    pub prev: *mut k_list_node_st,
}

impl Default for k_list_node_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_list_t = k_list_node_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pend_object_st {
    pub list: k_list_t,
}

impl Default for pend_object_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pend_obj_t = pend_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_ring_queue_st {
    pub knl_obj: knl_obj_t,
    pub head: u16,
    pub tail: u16,
    pub total: usize,
    pub pool: *mut u8,
    pub item_size: usize,
    pub item_cnt: usize,
}

impl Default for k_ring_queue_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_ring_q_t = k_ring_queue_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mail_queue_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub ring_q: k_ring_q_t,
}
impl Default for k_mail_queue_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_mail_q_t = k_mail_queue_st;

pub type k_tick_t = u32;
pub type k_opt_t = u16;
pub type k_event_flag_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_event_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub flag: k_event_flag_t,
}

impl Default for k_event_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_event_t = k_event_st;

pub type k_sem_cnt_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_sem_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub count: k_sem_cnt_t,
    pub count_max: k_sem_cnt_t,
}

impl Default for k_sem_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_sem_t = k_sem_st;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_char_fifo_st {
    pub knl_obj: knl_obj_t,
    pub ring_q: k_ring_q_t,
}

impl Default for k_char_fifo_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_chr_fifo_t = k_char_fifo_st;

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pend_state_en {
    #[doc = "< nothing."]
    PEND_STATE_NONE = 0,
    #[doc = "< someone has post, we get what we want."]
    PEND_STATE_POST = 1,
    #[doc = "< a post has never came until time is out."]
    PEND_STATE_TIMEOUT = 2,
    #[doc = "< someone has destroyed what we are pending for."]
    PEND_STATE_DESTROY = 3,
    #[doc = "< the pend object owner task is destroyed."]
    PEND_STATE_OWNER_DIE = 4,
}
pub use self::pend_state_en as pend_state_t;
pub type k_prio_t = u8;
pub type k_stack_t = u8;
pub type k_task_state_t = u8;
pub type k_task_entry_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
pub type k_timeslice_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_task_st {
    #[doc = "< task stack pointer. This lady always comes first, we count on her in port_s.S for context switch."]
    pub sp: *mut k_stack_t,
    #[doc = "< just for verification, test whether current object is really a task."]
    pub knl_obj: knl_obj_t,
    #[doc = "< task name"]
    pub name: [c_char; 16usize],
    #[doc = "< task entry"]
    pub entry: k_task_entry_t,
    #[doc = "< argument for task entry"]
    pub arg: *mut ::core::ffi::c_void,
    #[doc = "< just state"]
    pub state: k_task_state_t,
    #[doc = "< just priority"]
    pub prio: k_prio_t,
    #[doc = "< task stack base address"]
    pub stk_base: *mut k_stack_t,
    #[doc = "< stack size of the task"]
    pub stk_size: c_ulong,
    #[doc = "< list for hooking us to the k_stat_list"]
    pub stat_list: k_list_t,
    #[doc = "< if we are in k_tick_list, how much time will we wait for?"]
    pub tick_expires: k_tick_t,
    #[doc = "< list for hooking us to the k_tick_list"]
    pub tick_list: k_list_t,
    #[doc = "< when we are ready, our pend_list is in readyqueue; when pend, in a certain pend object's list."]
    pub pend_list: k_list_t,
    #[doc = "< the list hold all the mutex we own."]
    #[doc = "When we die(tos_task_destroy), we have an obligation to wakeup all the task pending for those mutexs we own;"]
    #[doc = "if not, those pending tasks may never get a chance to wakeup."]
    pub mutex_own_list: k_list_t,
    pub prio_pending: k_prio_t,
    #[doc = "< if we are pending, which pend object's list we are in?"]
    pub pending_obj: *mut pend_obj_t,
    #[doc = "< why we wakeup from a pend"]
    pub pend_state: pend_state_t,
    #[doc = "< if current time slice is used up, use time_slice_reload to reload our time slice"]
    pub timeslice_reload: k_timeslice_t,
    #[doc = "< how much time slice left for us?"]
    pub timeslice: k_timeslice_t,
    #[doc = "< if we pend a mail queue successfully, our mail and mail_size will be set by the message queue poster"]
    pub mail: *mut ::core::ffi::c_void,
    pub mail_size: c_ulong,
    #[doc = "< if we are pending an event, what's the option for the pending(TOS_OPT_EVENT_PEND_*)?"]
    pub opt_event_pend: k_opt_t,
    #[doc = "< if we are pending an event, what event flag are we pending for ?"]
    pub flag_expect: k_event_flag_t,
    #[doc = "< if we pend an event successfully, flag_match will be set by the event poster, and will be returned"]
    #[doc = "by tos_event_pend to the caller"]
    pub flag_match: *mut k_event_flag_t,
}
impl Default for k_task_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_task_t = k_task_st;
pub type k_task_walker_t = ::core::option::Option<unsafe extern "C" fn(task: *mut k_task_t)>;



/// These glue functions are from tosglue.c
extern {
    //CMSIS
    // osStatus osKernelStart(void);
    // int32_t osKernelRunning(void);
    pub fn rust_osKernelRunning() -> i32;
    pub fn rust_osKernelSysTick() ->u32;

    //system management
    pub fn rust_tos_knl_is_running() -> i32;
    pub fn rust_tos_knl_irq_enter();
    pub fn rust_tos_knl_irq_leave();
    pub fn rust_tos_knl_sched_lock() -> k_err_t;
    pub fn rust_tos_knl_sched_unlock() -> k_err_t;

    //tos task
    pub fn rust_tos_task_create(
        task: *mut k_task_t,
        name: *mut c_char,
        entry: k_task_entry_t,
        arg: *mut ::core::ffi::c_void,
        prio: k_prio_t,
        stk_base: *mut k_stack_t,
        stk_size: c_ulong,
        timeslice: k_timeslice_t,
    ) -> k_err_t;

    pub fn rust_tos_task_destroy(task: *mut k_task_t) -> k_err_t;

    pub fn rust_tos_task_create_dyn(
        task: *mut *mut k_task_t,
        name: *mut c_char,
        entry: k_task_entry_t,
        arg: *mut ::core::ffi::c_void,
        prio: k_prio_t,
        stk_size: c_ulong,
        timeslice: k_timeslice_t,
    ) -> k_err_t;

    pub fn rust_tos_task_delay(delay: k_tick_t) -> k_err_t;

    pub fn rust_tos_task_delay_abort(task: *mut k_task_t) -> k_err_t;

    pub fn rust_tos_task_suspend(task: *mut k_task_t) -> k_err_t;

    pub fn rust_tos_task_resume(task: *mut k_task_t) -> k_err_t;

    pub fn rust_tos_task_prio_change(task: *mut k_task_t, prio_new: k_prio_t) -> k_err_t;

    pub fn rust_tos_task_yield();

    pub fn rust_tos_task_curr_task_get() -> *mut k_task_t;

    pub fn rust_tos_task_stack_draught_depth(
        task: *mut k_task_t,
        depth: *mut c_int,
    ) -> k_err_t;

    pub fn rust_tos_task_walkthru(walker: k_task_walker_t);



    // tos_mutex


    //tos_mail
    pub fn rust_tos_mail_q_create(
        mail_q: *mut k_mail_q_t,
        pool: *mut ::core::ffi::c_void,
        mail_cnt: usize,
        mail_size: usize,
    ) -> k_err_t;


    
    //tos_event
    pub fn rust_tos_event_create(event : *mut k_event_t , init_flag :  k_event_flag_t) -> k_err_en;
    pub fn rust_tos_event_destroy(event : *mut k_event_t) -> k_err_en;
    pub fn rust_tos_event_post(event: *mut k_event_t, flag: k_event_flag_t) -> k_err_t;
    pub fn rust_tos_event_post_keep(event: *mut k_event_t, flag: k_event_flag_t) -> k_err_t;
    pub fn rust_tos_event_pend(
        event: *mut k_event_t,
        flag_expect: k_event_flag_t,
        flag_match: *mut k_event_flag_t,
        timeout: k_tick_t,
        opt_pend: k_opt_t,
    ) -> k_err_t;




    //tos_sem 
    pub fn rust_tos_sem_create_max(
        sem: *mut k_sem_t,
        init_count: k_sem_cnt_t,
        max_count: k_sem_cnt_t,
    ) -> k_err_t;

    pub fn rust_tos_sem_create(sem: *mut k_sem_t, init_count: k_sem_cnt_t) -> k_err_t;

    pub fn rust_tos_sem_create_max_dyn(
        sem: *mut *mut k_sem_t,
        init_count: k_sem_cnt_t,
        max_count: k_sem_cnt_t,
    ) -> k_err_t;

    pub fn rust_tos_sem_create_dyn(sem: *mut *mut k_sem_t, init_count: k_sem_cnt_t) -> k_err_t;

    pub fn rust_tos_sem_destroy(sem: *mut k_sem_t) -> k_err_t;

    pub fn rust_tos_sem_pend(sem: *mut k_sem_t, timeout: k_tick_t) -> k_err_t;

    pub fn rust_tos_sem_post(sem: *mut k_sem_t) -> k_err_t;

    pub fn rust_tos_sem_post_all(sem: *mut k_sem_t) -> k_err_t;




    //tos_chr_fifo
    pub fn rust_tos_chr_fifo_create(
        chr_fifo: *mut k_chr_fifo_t,
        buffer: *mut ::core::ffi::c_void,
        size: usize,
    ) -> k_err_t;

    pub fn rust_tos_chr_fifo_destroy(chr_fifo: *mut k_chr_fifo_t) -> k_err_t;

    pub fn rust_tos_chr_fifo_create_dyn(
        chr_fifo: *mut k_chr_fifo_t,
        fifo_size: usize,
    ) -> k_err_t;

    pub fn rust_tos_chr_fifo_destroy_dyn(chr_fifo: *mut k_chr_fifo_t) -> k_err_t;

    pub fn rust_tos_chr_fifo_push(chr_fifo: *mut k_chr_fifo_t, data: c_char)
        -> k_err_t;

    pub fn rust_tos_chr_fifo_push_stream(
        chr_fifo: *mut k_chr_fifo_t,
        stream: *mut u8,
        size: usize,
    ) -> i32;

    pub fn rust_tos_chr_fifo_pop(
        chr_fifo: *mut k_chr_fifo_t,
        out: *mut u8,
    ) -> k_err_t;

    pub fn rust_tos_chr_fifo_pop_stream(
        chr_fifo: *mut k_chr_fifo_t,
        buffer: *mut u8,
        size: usize,
    ) -> i32;

    pub fn rust_tos_chr_fifo_flush(chr_fifo: *mut k_chr_fifo_t) -> k_err_t;

    pub fn rust_tos_chr_fifo_is_empty(chr_fifo: *mut k_chr_fifo_t) -> i32;

    pub fn rust_tos_chr_fifo_is_full(chr_fifo: *mut k_chr_fifo_t) -> i32;







    //OLED
    pub fn rust_oled_print(x : u32, y : u32 ,msg: *const u8);
    pub fn rust_oled_init();
    pub fn rust_oled_clear();  


    pub fn rust_print_num(num : u32);
    pub fn rust_print_i32(num : i32);

    pub fn rust_print(msg: *const u8);

    pub fn rust_print_char(msg: *const u8);
    
    //wifi
    pub fn rust_wifi_init() -> c_int;
    pub fn rust_wifi_connect(ssid: *const u8, passwd: *const u8);
    
    pub fn rust_sleep(ms: u32);
    pub fn rust_mqtt_daemon() -> c_void;
   
}


