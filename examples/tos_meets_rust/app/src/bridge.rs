
use cty::*;
/* automatically generated by rust-bindgen 0.59.1 */
pub type size_t = c_ulong;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k_err_en {
    K_ERR_NONE = 0,
    K_ERR_BARRIER_COUNT_INVALID = 5,
    K_ERR_BARRIER_OVERFLOW = 6,
    K_ERR_BITMAP_EXCEED = 10,
    K_ERR_BIN_HEAP_FULL = 15,
    K_ERR_BIN_HEAP_EMPTY = 16,
    K_ERR_BIN_HEAP_ITEM_SIZE_NOT_MATCH = 17,
    K_ERR_COMPLETION_OVERFLOW = 25,
    K_ERR_COUNTDOWNLATCH_OVERFLOW = 50,
    K_ERR_DELAY_ZERO = 100,
    K_ERR_DELAY_FOREVER = 101,
    K_ERR_EVENT_PEND_OPT_INVALID = 200,
    K_ERR_IN_IRQ = 400,
    K_ERR_KNL_NOT_RUNNING = 500,
    K_ERR_KNL_RUNNING = 501,
    K_ERR_LOCK_NESTING_OVERFLOW = 600,
    K_ERR_MMBLK_POOL_FULL = 700,
    K_ERR_MMBLK_POOL_EMPTY = 701,
    K_ERR_MMBLK_INVALID_BLK_SIZE = 702,
    K_ERR_MMBLK_INVALID_POOL_ADDR = 703,
    K_ERR_MMBLK_POOL_OUT_OF_MEMORY = 704,
    K_ERR_MMBLK_OUT_OF_MEMORY = 705,
    K_ERR_MMHEAP_INVALID_POOL_ADDR = 800,
    K_ERR_MMHEAP_INVALID_POOL_SIZE = 801,
    K_ERR_MMHEAP_POOL_OVERFLOW = 802,
    K_ERR_MMHEAP_POOL_ALREADY_EXIST = 803,
    K_ERR_MMHEAP_POOL_NOT_EXIST = 804,
    K_ERR_MUTEX_NOT_OWNER = 1000,
    K_ERR_MUTEX_NESTING = 1001,
    K_ERR_MUTEX_NESTING_OVERFLOW = 1002,
    K_ERR_OBJ_PTR_NULL = 1100,
    K_ERR_OBJ_INVALID = 1101,
    K_ERR_OBJ_INVALID_ALLOC_TYPE = 1102,
    K_ERR_OUT_OF_MEMORY = 1150,
    K_ERR_PEND_NOWAIT = 1200,
    K_ERR_PEND_SCHED_LOCKED = 1201,
    K_ERR_PEND_ABNORMAL = 1202,
    K_ERR_PEND_TIMEOUT = 1203,
    K_ERR_PEND_DESTROY = 1204,
    K_ERR_PEND_OWNER_DIE = 1205,
    K_ERR_PM_DEVICE_ALREADY_REG = 1300,
    K_ERR_PM_DEVICE_OVERFLOW = 1301,
    K_ERR_PM_WKUP_SOURCE_NOT_INSTALL = 1302,
    K_ERR_PRIO_Q_EMPTY = 1400,
    K_ERR_PRIO_Q_FULL = 1401,
    K_ERR_PRIO_Q_SLOT_NOT_TAKEN = 1402,
    K_ERR_PRIO_Q_ITEM_SIZE_NOT_MATCH = 1403,
    K_ERR_RING_Q_FULL = 1500,
    K_ERR_RING_Q_EMPTY = 1501,
    K_ERR_RING_Q_ITEM_SIZE_NOT_MATCH = 1502,
    K_ERR_RWLOCK_READERS_TO_MANY = 1600,
    K_ERR_RWLOCK_IS_READING = 1601,
    K_ERR_RWLOCK_IS_WRITTING = 1602,
    K_ERR_RWLOCK_NOT_READING = 1603,
    K_ERR_RWLOCK_NOT_WRITTING = 1604,
    K_ERR_RWLOCK_NOT_TAKEN = 1605,
    K_ERR_RWLOCK_WAITING_WRITERS_TO_MANY = 1606,
    K_ERR_SCHED_LOCKED = 1700,
    K_ERR_SCHED_NOT_LOCKED = 1701,
    K_ERR_SEM_OVERFLOW = 1800,
    K_ERR_TASK_ALREADY_CREATED = 1900,
    K_ERR_TASK_DESTROY_IDLE = 1901,
    K_ERR_TASK_NOT_DELAY = 1902,
    K_ERR_TASK_PRIO_INVALID = 1903,
    K_ERR_TASK_RESUME_SELF = 1904,
    K_ERR_TASK_SUSPENDED = 1905,
    K_ERR_TASK_SUSPEND_IDLE = 1906,
    K_ERR_TASK_STK_OVERFLOW = 1907,
    K_ERR_TASK_STK_SIZE_INVALID = 1908,
    K_ERR_TASK_OUT_OF_MEMORY = 1909,
    K_ERR_TICKLESS_WKUP_ALARM_NOT_INSTALLED = 2000,
    K_ERR_TICKLESS_WKUP_ALARM_NO_INIT = 2001,
    K_ERR_TICKLESS_WKUP_ALARM_INIT_FAILED = 2002,
    K_ERR_TIMER_INACTIVE = 2100,
    K_ERR_TIMER_DELAY_FOREVER = 2101,
    K_ERR_TIMER_PERIOD_FOREVER = 2102,
    K_ERR_TIMER_INVALID_DELAY = 2103,
    K_ERR_TIMER_INVALID_PERIOD = 2104,
    K_ERR_TIMER_INVALID_STATE = 2105,
    K_ERR_TIMER_INVALID_OPT = 2106,
    K_ERR_TIMER_STOPPED = 2107,
    K_ERR_TIMER_RUNNING = 2108,
    K_ERR_SEM_OUT_OF_MEMORY = 2200,
    K_ERR_MUTEX_OUT_OF_MEMORY = 2300,
}
pub use self::k_err_en as k_err_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum knl_obj_alloc_type_en {
    KNL_OBJ_ALLOC_TYPE_NONE = 0,
    KNL_OBJ_ALLOC_TYPE_STATIC = 1,
    KNL_OBJ_ALLOC_TYPE_DYNAMIC = 2,
}
pub use self::knl_obj_alloc_type_en as knl_obj_alloc_type_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct knl_object_st {
    pub alloc_type: knl_obj_alloc_type_t,
}
impl Default for knl_object_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type knl_obj_t = knl_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_list_node_st {
    pub next: *mut k_list_node_st,
    pub prev: *mut k_list_node_st,
}

impl Default for k_list_node_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_list_t = k_list_node_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pend_object_st {
    pub list: k_list_t,
}

impl Default for pend_object_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pend_obj_t = pend_object_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_ring_queue_st {
    pub knl_obj: knl_obj_t,
    pub head: u16,
    pub tail: u16,
    pub total: usize,
    pub pool: *mut u8,
    pub item_size: usize,
    pub item_cnt: usize,
}

impl Default for k_ring_queue_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_ring_q_t = k_ring_queue_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mail_queue_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub ring_q: k_ring_q_t,
}
impl Default for k_mail_queue_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_mail_q_t = k_mail_queue_st;

pub type k_tick_t = u32;
pub type k_opt_t = u16;
pub type k_event_flag_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_event_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub flag: k_event_flag_t,
}

impl Default for k_event_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_event_t = k_event_st;

pub type k_sem_cnt_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_sem_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub count: k_sem_cnt_t,
    pub count_max: k_sem_cnt_t,
}

impl Default for k_sem_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_sem_t = k_sem_st;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_char_fifo_st {
    pub knl_obj: knl_obj_t,
    pub ring_q: k_ring_q_t,
}

impl Default for k_char_fifo_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_chr_fifo_t = k_char_fifo_st;

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pend_state_en {
    #[doc = "< nothing."]
    PEND_STATE_NONE = 0,
    #[doc = "< someone has post, we get what we want."]
    PEND_STATE_POST = 1,
    #[doc = "< a post has never came until time is out."]
    PEND_STATE_TIMEOUT = 2,
    #[doc = "< someone has destroyed what we are pending for."]
    PEND_STATE_DESTROY = 3,
    #[doc = "< the pend object owner task is destroyed."]
    PEND_STATE_OWNER_DIE = 4,
}
pub use self::pend_state_en as pend_state_t;
pub type k_prio_t = u8;
pub type k_stack_t = u8;
pub type k_task_state_t = u8;
pub type k_task_entry_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
pub type k_timeslice_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_task_st {
    #[doc = "< task stack pointer. This lady always comes first, we count on her in port_s.S for context switch."]
    pub sp: *mut k_stack_t,
    #[doc = "< just for verification, test whether current object is really a task."]
    pub knl_obj: knl_obj_t,
    #[doc = "< task name"]
    pub name: [c_char; 16usize],
    #[doc = "< task entry"]
    pub entry: k_task_entry_t,
    #[doc = "< argument for task entry"]
    pub arg: *mut ::core::ffi::c_void,
    #[doc = "< just state"]
    pub state: k_task_state_t,
    #[doc = "< just priority"]
    pub prio: k_prio_t,
    #[doc = "< task stack base address"]
    pub stk_base: *mut k_stack_t,
    #[doc = "< stack size of the task"]
    pub stk_size: c_ulong,
    #[doc = "< list for hooking us to the k_stat_list"]
    pub stat_list: k_list_t,
    #[doc = "< if we are in k_tick_list, how much time will we wait for?"]
    pub tick_expires: k_tick_t,
    #[doc = "< list for hooking us to the k_tick_list"]
    pub tick_list: k_list_t,
    #[doc = "< when we are ready, our pend_list is in readyqueue; when pend, in a certain pend object's list."]
    pub pend_list: k_list_t,
    #[doc = "< the list hold all the mutex we own."]
    #[doc = "When we die(tos_task_destroy), we have an obligation to wakeup all the task pending for those mutexs we own;"]
    #[doc = "if not, those pending tasks may never get a chance to wakeup."]
    pub mutex_own_list: k_list_t,
    pub prio_pending: k_prio_t,
    #[doc = "< if we are pending, which pend object's list we are in?"]
    pub pending_obj: *mut pend_obj_t,
    #[doc = "< why we wakeup from a pend"]
    pub pend_state: pend_state_t,
    #[doc = "< if current time slice is used up, use time_slice_reload to reload our time slice"]
    pub timeslice_reload: k_timeslice_t,
    #[doc = "< how much time slice left for us?"]
    pub timeslice: k_timeslice_t,
    #[doc = "< if we pend a mail queue successfully, our mail and mail_size will be set by the message queue poster"]
    pub mail: *mut ::core::ffi::c_void,
    pub mail_size: c_ulong,
    #[doc = "< if we are pending an event, what's the option for the pending(TOS_OPT_EVENT_PEND_*)?"]
    pub opt_event_pend: k_opt_t,
    #[doc = "< if we are pending an event, what event flag are we pending for ?"]
    pub flag_expect: k_event_flag_t,
    #[doc = "< if we pend an event successfully, flag_match will be set by the event poster, and will be returned"]
    #[doc = "by tos_event_pend to the caller"]
    pub flag_match: *mut k_event_flag_t,
}
impl Default for k_task_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_task_t = k_task_st;
pub type k_task_walker_t = ::core::option::Option<unsafe extern "C" fn(task: *mut k_task_t)>;
pub type k_time_t = c_uint;

#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct k_mmheap_information_st {
    pub used: c_uint,
    pub free: c_uint,
}
pub type k_mmheap_info_t = k_mmheap_information_st;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mmblk_pool_st {
    pub knl_obj: knl_obj_t,
    pub pool_start: *mut ::core::ffi::c_void,
    pub free_list: *mut ::core::ffi::c_void,
    pub blk_size: c_ulong,
    pub blk_max: c_ulong,
    pub blk_free: c_ulong,
}

impl Default for k_mmblk_pool_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_mmblk_pool_t = k_mmblk_pool_st;

pub type k_nesting_t = c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_mutex_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub pend_nesting: k_nesting_t,
    pub owner: *mut k_task_t,
    pub owner_orig_prio: k_prio_t,
    pub owner_anchor: k_list_t,
}
impl Default for k_mutex_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_mutex_t = k_mutex_st;


pub type completion_done_t = c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_completion_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub done: completion_done_t,
}
impl Default for k_completion_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_completion_t = k_completion_st;

pub type k_countdownlatch_cnt_t = c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_countdownlatch_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub count: k_countdownlatch_cnt_t,
}

impl Default for k_countdownlatch_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_countdownlatch_t = k_countdownlatch_st;

pub type k_barrier_cnt_t = c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_barrier_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub count: k_barrier_cnt_t,
}
impl Default for k_barrier_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_barrier_t = k_barrier_st;
pub type rw_cnt_t = c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_rwlock_st {
    pub knl_obj: knl_obj_t,
    pub lock: k_mutex_t,
    pub signal: k_sem_t,
    pub n_readers: rw_cnt_t,
    pub n_writers: rw_cnt_t,
    pub is_writting: c_int,
}
impl Default for k_rwlock_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_rwlock_t = k_rwlock_st;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_message_queue_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub ring_q: k_ring_q_t,
}
impl Default for k_message_queue_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_msg_q_t = k_message_queue_st;


pub type k_bin_heap_cmp = ::core::option::Option<
    unsafe extern "C" fn(
        first: *mut ::core::ffi::c_void,
        second: *mut ::core::ffi::c_void,
    ) -> c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_binary_heap_st {
    pub knl_obj: knl_obj_t,
    pub total: size_t,
    pub cmp: k_bin_heap_cmp,
    pub item_size: size_t,
    pub item_cnt: size_t,
    pub pool: *mut u8,
}
impl Default for k_binary_heap_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_bin_heap_t = k_binary_heap_st;
pub type prio_q_slot_t = u16;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct prio_q_pool_manager_entry_st {
    pub next: prio_q_slot_t,
}
pub type prio_q_pool_mgr_ent_t = prio_q_pool_manager_entry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prio_q_pool_manager_st {
    pub first_free: prio_q_slot_t,
    pub pool_mgr_ent_array: *mut prio_q_pool_mgr_ent_t,
}
impl Default for prio_q_pool_manager_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type prio_q_pool_mgr_t = prio_q_pool_manager_st;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct prio_q_priority_manager_entry_st {
    pub priority: k_prio_t,
    pub slot: prio_q_slot_t,
}
pub type prio_q_prio_mgr_ent_t = prio_q_priority_manager_entry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prio_q_prio_manager_st {
    pub prio_mgr_bin_heap: k_bin_heap_t,
    pub prio_mgr_ent_pool: *mut prio_q_prio_mgr_ent_t,
}
impl Default for prio_q_prio_manager_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type prio_q_prio_mgr_t = prio_q_prio_manager_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_priority_queue_st {
    pub knl_obj: knl_obj_t,
    pub pool_mgr: prio_q_pool_mgr_t,
    pub prio_mgr: prio_q_prio_mgr_t,
    pub total: size_t,
    pub item_size: size_t,
    pub item_cnt: size_t,
    pub mgr_pool: *mut u8,
    pub data_pool: *mut u8,
}
impl Default for k_priority_queue_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_prio_q_t = k_priority_queue_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_priority_message_queue_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub prio_q_mgr_array: *mut ::core::ffi::c_void,
    pub prio_q: k_prio_q_t,
}
impl Default for k_priority_message_queue_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_prio_msg_q_t = k_priority_message_queue_st;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_priority_mail_queue_st {
    pub knl_obj: knl_obj_t,
    pub pend_obj: pend_obj_t,
    pub prio_q_mgr_array: *mut ::core::ffi::c_void,
    pub prio_q: k_prio_q_t,
}
impl Default for k_priority_mail_queue_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_prio_mail_q_t = k_priority_mail_queue_st;


#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum timer_change_type_en {
    TIMER_CHANGE_TYPE_DELAY = 0,
    TIMER_CHANGE_TYPE_PERIOD = 1,
}
pub use self::timer_change_type_en as timer_change_type_t;
#[repr(u32)]
#[doc = " state for timer"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum timer_state_en {
    #[doc = "< the timer has been destroyed"]
    TIMER_STATE_UNUSED = 0,
    #[doc = "< the timer has been created but not been started, or just be stopped(tos_timer_stop)"]
    TIMER_STATE_STOPPED = 1,
    #[doc = "< the timer has been created and been started"]
    TIMER_STATE_RUNNING = 2,
    #[doc = "< the timer has finished its expires, it can only happen when the timer's opt is TOS_OPT_TIMER_ONESHOT"]
    TIMER_STATE_COMPLETED = 3,
}
#[doc = " state for timer"]
pub use self::timer_state_en as timer_state_t;
pub type k_timer_callback_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[doc = " timer control block"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_timer_st {
    #[doc = "< just for verification, test whether current object is really a timer"]
    pub knl_obj: knl_obj_t,
    #[doc = "< callback when time is up"]
    pub cb: k_timer_callback_t,
    #[doc = "< argument for callback"]
    pub cb_arg: *mut ::core::ffi::c_void,
    #[doc = "< list for hooking us to the k_tick_list"]
    pub list: k_list_t,
    #[doc = "< how much time left until time expires"]
    pub expires: k_tick_t,
    #[doc = "< how much time from now to begin the first run of the timer"]
    pub delay: k_tick_t,
    #[doc = "< if the time expires, how much time after should we begin the next round"]
    pub period: k_tick_t,
    #[doc = "< option for the timer, see TOS_OPT_TIMER_*"]
    pub opt: k_opt_t,
    #[doc = "< state for the timer, see TIMER_STATE_*"]
    pub state: timer_state_t,
}
impl Default for k_timer_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " timer control block"]
pub type k_timer_t = k_timer_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_control_st {
    pub next_expires: k_tick_t,
    pub list: k_list_t,
}
impl Default for timer_control_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type timer_ctl_t = timer_control_st;



#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_stopwatch_st {
    pub knl_obj: knl_obj_t,
    pub until: k_tick_t,
}
impl Default for k_stopwatch_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_stopwatch_t = k_stopwatch_st;

pub type k_bmtbl_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_bitmap_st {
    pub knl_obj: knl_obj_t,
    pub bit_ndx_max: u32,
    pub bit_max: u32,
    pub bitmap_tbl: *mut k_bmtbl_t,
}
impl Default for k_bitmap_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_bitmap_t = k_bitmap_st;

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum k_cpu_low_power_mode_en {
    TOS_LOW_POWER_MODE_NONE = 0,
    TOS_LOW_POWER_MODE_SLEEP = 1,
    TOS_LOW_POWER_MODE_STOP = 2,
    TOS_LOW_POWER_MODE_STANDBY = 3,
    __LOW_POWER_MODE_DUMMY = 4,
}
pub use self::k_cpu_low_power_mode_en as k_cpu_lpwr_mode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_pm_device_st {
    pub name: *mut c_char,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> c_int>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn() -> c_int>,
    pub resume: ::core::option::Option<unsafe extern "C" fn() -> c_int>,
}
impl Default for k_pm_device_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type k_pm_device_t = k_pm_device_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pm_device_control_st {
    pub count: u8,
    pub mgr: [*mut k_pm_device_t; 10usize],
}
impl Default for pm_device_control_st {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pm_device_ctl_t = pm_device_control_st;

#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct k_tickless_wakeup_alarm_st {
    pub init: ::core::option::Option<unsafe extern "C" fn() -> c_int>,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(millisecond: k_time_t) -> c_int,
    >,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn() -> c_int>,
    pub max_delay: ::core::option::Option<unsafe extern "C" fn() -> k_time_t>,
}

pub type k_tickless_wkup_alarm_t = k_tickless_wakeup_alarm_st;


#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum osStatus {
    #[doc = "< function completed; no error or event occurred."]
    osOK = 0,
    #[doc = "< function completed; signal event occurred."]
    osEventSignal = 8,
    #[doc = "< function completed; message event occurred."]
    osEventMessage = 16,
    #[doc = "< function completed; mail event occurred."]
    osEventMail = 32,
    #[doc = "< function completed; timeout occurred."]
    osEventTimeout = 64,
    #[doc = "< parameter error: a mandatory parameter was missing or specified an incorrect object."]
    osErrorParameter = 128,
    #[doc = "< resource not available: a specified resource was not available."]
    osErrorResource = 129,
    #[doc = "< resource not available within given time: a specified resource was not available within the timeout period."]
    osErrorTimeoutResource = 193,
    #[doc = "< not allowed in ISR context: the function cannot be called from interrupt service routines."]
    osErrorISR = 130,
    #[doc = "< function called multiple times from ISR with same object."]
    osErrorISRRecursive = 131,
    #[doc = "< system cannot determine priority or thread has illegal priority."]
    osErrorPriority = 132,
    #[doc = "< system is out of memory: it was impossible to allocate or reserve memory for the operation."]
    osErrorNoMemory = 133,
    #[doc = "< value of a parameter is out of range."]
    osErrorValue = 134,
    #[doc = "< unspecified RTOS error: run-time error but no other error message fits."]
    osErrorOS = 255,
    #[doc = "< prevent from enum down-size compiler optimization."]
    os_status_reserved = 2147483647,
}

#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum osPriority {
    #[doc = "< priority: idle (lowest)"]
    osPriorityIdle = -3,
    #[doc = "< priority: low"]
    osPriorityLow = -2,
    #[doc = "< priority: below normal"]
    osPriorityBelowNormal = -1,
    #[doc = "< priority: normal (default)"]
    osPriorityNormal = 0,
    #[doc = "< priority: above normal"]
    osPriorityAboveNormal = 1,
    #[doc = "< priority: high"]
    osPriorityHigh = 2,
    #[doc = "< priority: realtime (highest)"]
    osPriorityRealtime = 3,
    #[doc = "< system cannot determine priority or thread has illegal priority"]
    osPriorityError = 132,
}
pub type osThreadId = *mut k_task_t;
pub type os_pthread =
    ::core::option::Option<unsafe extern "C" fn(argument: *const ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_thread_def {
    #[doc = "< Thread name"]
    pub name: *mut c_char,
    #[doc = "< start address of thread function"]
    pub pthread: os_pthread,
    #[doc = "< initial thread priority"]
    pub tpriority: osPriority,
    #[doc = "< maximum number of instances of that thread function"]
    pub instances: u32,
    #[doc = "< base address of task"]
    pub stackbase: *mut k_stack_t,
    #[doc = "< stack size requirements in bytes; 0 is default stack size"]
    pub stacksize: u32,
    #[doc = "< timeslice"]
    pub timeslice: k_timeslice_t,
    pub task: *mut k_task_t,
}

impl Default for os_thread_def {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type osThreadDef_t = os_thread_def;

#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum os_timer_type {
    #[doc = "< one-shot timer"]
    osTimerOnce = 0,
    #[doc = "< repeating timer"]
    osTimerPeriodic = 1,
}
pub type osTimerId = *mut k_timer_t;
pub type os_ptimer =
    ::core::option::Option<unsafe extern "C" fn(argument: *const ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_timer_def {
    #[doc = "< start address of a timer function"]
    pub cb: os_ptimer,
    pub timer: *mut k_timer_t,
}

impl Default for os_timer_def {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type osTimerDef_t = os_timer_def;

pub type osMutexId = *mut k_mutex_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mutex_def {
    #[doc = "< dummy value."]
    pub dummy: u32,
    pub mutex: *mut k_mutex_t,
}
impl Default for os_mutex_def {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type osMutexDef_t = os_mutex_def;
pub type osSemaphoreId = *mut k_sem_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_semaphore_def {
    #[doc = "< dummy value."]
    pub dummy: u32,
    pub sem: *mut k_sem_t,
}

impl Default for os_semaphore_def {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type osSemaphoreDef_t = os_semaphore_def;
pub type osPoolId = *mut k_mmblk_pool_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_pool_def {
    #[doc = "< number of items (elements) in the pool"]
    pub pool_sz: u32,
    #[doc = "< size of an item"]
    pub item_sz: u32,
    #[doc = "< pointer to memory for pool"]
    pub pool: *mut ::core::ffi::c_void,
    #[doc = "< memory blk pool handler"]
    pub mmblk_pool: *mut k_mmblk_pool_t,
}

impl Default for os_pool_def {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type osPoolDef_t = os_pool_def;
pub type osMessageQId = *mut k_msg_q_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_messageQ_def {
    #[doc = "< number of elements in the queue"]
    pub queue_sz: u32,
    #[doc = "< size of an item"]
    pub item_sz: u32,
    #[doc = "< memory array for messages"]
    pub pool: *mut ::core::ffi::c_void,
    #[doc = "< queue handler"]
    pub queue: *mut k_msg_q_t,
}

impl Default for os_messageQ_def {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type osMessageQDef_t = os_messageQ_def;
pub type osMailQId = *mut k_mail_q_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct osEvent {
    #[doc = "< status code: event or error information"]
    pub status: osStatus,
    #[doc = "< event value"]
    pub value: osEvent__bindgen_ty_1,
    #[doc = "< event definition"]
    pub def: osEvent__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union osEvent__bindgen_ty_1 {
    #[doc = "< message as 32-bit value"]
    pub v: u32,
    #[doc = "< message or mail as void pointer"]
    pub p: *mut ::core::ffi::c_void,
    #[doc = "< signal flags"]
    pub signals: i32,
}

impl Default for osEvent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union osEvent__bindgen_ty_2 {
    #[doc = "< mail id obtained by \\ref osMailCreate"]
    pub mail_id: osMailQId,
}

impl Default for osEvent__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}

impl Default for osEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}


/// These glue functions are from tosglue.c
extern {
//************************CMSIS************************

    pub fn rust_osKernelInitialize() -> osStatus;
    pub fn rust_osKernelStart() -> osStatus;
    pub fn rust_osKernelRunning() -> i32;
    pub fn rust_osKernelSysTick() -> u32;

    pub fn rust_osThreadCreate(
        thread_def: *const osThreadDef_t,
        argument: *mut ::core::ffi::c_void,
    ) -> osThreadId;
    pub fn rust_osThreadGetId() -> osThreadId;
    pub fn rust_osThreadTerminate(thread_id: osThreadId) -> osStatus;
    pub fn rust_osThreadYield() -> osStatus;
    pub fn rust_osThreadSetPriority(thread_id: osThreadId, priority: osPriority) -> osStatus;
    pub fn rust_osThreadGetPriority(thread_id: osThreadId) -> osPriority;


    pub fn rust_osDelay(millisec: u32) -> osStatus;
    pub fn rust_osTimerCreate(
        timer_def: *const osTimerDef_t,
        type_: os_timer_type,
        argument: *mut ::core::ffi::c_void,
    ) -> osTimerId;
    pub fn rust_osTimerStart(timer_id: osTimerId, millisec: u32) -> osStatus;
    pub fn rust_osTimerStop(timer_id: osTimerId) -> osStatus;
    pub fn rust_osTimerDelete(timer_id: osTimerId) -> osStatus;

    pub fn rust_osMutexCreate(mutex_def: *const osMutexDef_t) -> osMutexId;
    pub fn rust_osMutexWait(mutex_id: osMutexId, millisec: u32) -> osStatus;
    pub fn rust_osMutexRelease(mutex_id: osMutexId) -> osStatus;
    pub fn rust_osMutexDelete(mutex_id: osMutexId) -> osStatus;

    pub fn rust_osSemaphoreCreate(semaphore_def: *const osSemaphoreDef_t, count: i32) -> osSemaphoreId;
    pub fn rust_osSemaphoreWait(semaphore_id: osSemaphoreId, millisec: u32) -> i32;
    pub fn rust_osSemaphoreRelease(semaphore_id: osSemaphoreId) -> osStatus;
    pub fn rust_osSemaphoreDelete(semaphore_id: osSemaphoreId) -> osStatus;

    pub fn rust_osPoolCreate(pool_def: *const osPoolDef_t) -> osPoolId;
    pub fn rust_osPoolAlloc(pool_id: osPoolId) -> *mut ::core::ffi::c_void;
    pub fn rust_osPoolCAlloc(pool_id: osPoolId) -> *mut ::core::ffi::c_void;
    pub fn rust_osPoolFree(pool_id: osPoolId, block: *mut ::core::ffi::c_void) -> osStatus;

    pub fn rust_osMessageCreate(
        queue_def: *const osMessageQDef_t,
        thread_id: osThreadId,
    ) -> osMessageQId;
    pub fn rust_osMessagePut(queue_id: osMessageQId, info: u32, millisec: u32) -> osStatus;
    pub fn rust_osMessageGet(queue_id: osMessageQId, millisec: u32) -> osEvent;

       
//************************CMSIS************************

//************************system management************************
    pub fn rust_tos_knl_is_running() -> i32;
    pub fn rust_tos_knl_irq_enter();
    pub fn rust_tos_knl_irq_leave();
    pub fn rust_tos_knl_sched_lock() -> k_err_t;
    pub fn rust_tos_knl_sched_unlock() -> k_err_t;
//************************system management************************


//************************tos task**************************************
    pub fn rust_tos_task_create(
        task: *mut k_task_t,
        name: *mut c_char,
        entry: k_task_entry_t,
        arg: *mut ::core::ffi::c_void,
        prio: k_prio_t,
        stk_base: *mut k_stack_t,
        stk_size: c_ulong,
        timeslice: k_timeslice_t,
    ) -> k_err_t;

    pub fn rust_tos_task_destroy(task: *mut k_task_t) -> k_err_t;

    pub fn rust_tos_task_create_dyn(
        task: *mut *mut k_task_t,
        name: *mut c_char,
        entry: k_task_entry_t,
        arg: *mut ::core::ffi::c_void,
        prio: k_prio_t,
        stk_size: c_ulong,
        timeslice: k_timeslice_t,
    ) -> k_err_t;

    pub fn rust_tos_task_delay(delay:*mut  k_tick_t) -> k_err_t;

    pub fn rust_tos_task_delay_abort(task: *mut k_task_t) -> k_err_t;

    pub fn rust_tos_task_suspend(task: *mut k_task_t) -> k_err_t;

    pub fn rust_tos_task_resume(task: *mut k_task_t) -> k_err_t;

    pub fn rust_tos_task_prio_change(task: *mut k_task_t, prio_new: k_prio_t) -> k_err_t;

    pub fn rust_tos_task_yield();

    pub fn rust_tos_task_curr_task_get() -> *mut k_task_t;

    pub fn rust_tos_task_stack_draught_depth(
        task: *mut k_task_t,
        depth: *mut c_int,
    ) -> k_err_t;

    pub fn rust_tos_task_walkthru(walker: k_task_walker_t);
//************************tos task**************************************



//************************tos mmheap************************
    pub fn rust_tos_mmheap_pool_add(
        pool_start: *mut c_void,
        pool_size: c_ulong,
    ) -> k_err_t;

    pub fn rust_tos_mmheap_pool_rmv(pool_start: *mut c_void) -> k_err_t;

    pub fn rust_tos_mmheap_alloc(size: c_ulong) -> *mut c_void;

    pub fn rust_tos_mmheap_aligned_alloc(
        size: c_ulong,
        align: c_ulong,
    ) -> *mut c_void;

    pub fn rust_tos_mmheap_realloc(
        ptr: *mut c_void,
        size: c_ulong,
    ) -> *mut c_void;

    pub fn rust_tos_mmheap_free(ptr: *mut c_void);

    pub fn rust_tos_mmheap_pool_check(
        pool_start: *mut c_void,
        info: *mut k_mmheap_info_t,
    ) -> k_err_t;

    pub fn rust_tos_mmheap_check(info: *mut k_mmheap_info_t) -> k_err_t;
//************************tos mmheap************************

//************************start of tos mmblk************************

    pub fn rust_tos_mmblk_pool_create(
        mbp: *mut k_mmblk_pool_t,
        pool_start: *mut ::core::ffi::c_void,
        blk_num: c_ulong,
        blk_size: c_ulong,
    ) -> k_err_t;

    pub fn rust_tos_mmblk_pool_destroy(mbp: *mut k_mmblk_pool_t) -> k_err_t;

    pub fn rust_tos_mmblk_alloc(mbp: *mut k_mmblk_pool_t, blk: *mut *mut ::core::ffi::c_void)
        -> k_err_t;

    pub fn rust_tos_mmblk_free(mbp: *mut k_mmblk_pool_t, blk: *mut ::core::ffi::c_void) -> k_err_t;

    
//************************start of tos mmblk************************



//***************************  tos_mutex ****************************************
    pub fn rust_tos_mutex_create(mutex: *mut k_mutex_t) -> k_err_t;

    pub fn rust_tos_mutex_create_dyn(mutex: *mut *mut k_mutex_t) -> k_err_t;

    pub fn rust_tos_mutex_destroy(mutex: *mut k_mutex_t) -> k_err_t;

    pub fn rust_tos_mutex_pend_timed(mutex: *mut k_mutex_t, timeout:*mut k_tick_t) -> k_err_t;

    pub fn rust_tos_mutex_pend(mutex: *mut k_mutex_t) -> k_err_t;

    pub fn rust_tos_mutex_post(mutex: *mut k_mutex_t) -> k_err_t;

    pub fn rust_mutex_release(mutex: *mut k_mutex_t);
//***************************  tos_mutex ****************************************



//***************************  tos_mail ****************************************
    pub fn rust_tos_mail_q_create(
        mail_q: *mut k_mail_q_t,
        pool: *mut ::core::ffi::c_void,
        mail_cnt: size_t,
        mail_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_mail_q_destroy(mail_q: *mut k_mail_q_t) -> k_err_t;
    pub fn rust_tos_mail_q_create_dyn(
        mail_q: *mut k_mail_q_t,
        mail_cnt: size_t,
        mail_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_mail_q_destroy_dyn(mail_q: *mut k_mail_q_t) -> k_err_t;
    pub fn rust_tos_mail_q_flush(mail_q: *mut k_mail_q_t) -> k_err_t;
    pub fn rust_tos_mail_q_pend(
        mail_q: *mut k_mail_q_t,
        mail_buf: *mut ::core::ffi::c_void,
        mail_size: *mut size_t,
        timeout: *mut k_tick_t,
    ) -> k_err_t;
    pub fn rust_tos_mail_q_post(
        mail_q: *mut k_mail_q_t,
        mail_buf: *mut ::core::ffi::c_void,
        mail_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_mail_q_post_all(
        mail_q: *mut k_mail_q_t,
        mail_buf: *mut ::core::ffi::c_void,
        mail_size: size_t,
    ) -> k_err_t;
//***************************  tos_mail **************************************** 

//***************************  tos_prio_msg_q **************************************** 
    pub fn rust_tos_prio_msg_q_create(
        prio_msg_q: *mut k_prio_msg_q_t,
        pool: *mut ::core::ffi::c_void,
        msg_cnt: size_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_msg_q_destroy(prio_msg_q: *mut k_prio_msg_q_t) -> k_err_t;
    pub fn rust_tos_prio_msg_q_create_dyn(prio_msg_q: *mut k_prio_msg_q_t, msg_cnt: size_t) -> k_err_t;
    pub fn rust_tos_prio_msg_q_destroy_dyn(prio_msg_q: *mut k_prio_msg_q_t) -> k_err_t;
    pub fn rust_tos_prio_msg_q_flush(prio_msg_q: *mut k_prio_msg_q_t) -> k_err_t;
    pub fn rust_tos_prio_msg_q_pend(
        prio_msg_q: *mut k_prio_msg_q_t,
        msg_ptr: *mut *mut ::core::ffi::c_void,
        timeout: k_tick_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_msg_q_post(
        prio_msg_q: *mut k_prio_msg_q_t,
        msg_ptr: *mut ::core::ffi::c_void,
        prio: k_prio_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_msg_q_post_all(
        prio_msg_q: *mut k_prio_msg_q_t,
        msg_ptr: *mut ::core::ffi::c_void,
        prio: k_prio_t,
    ) -> k_err_t;
//***************************  tos_prio_msg_q **************************************** 

//***************************  tos_prio_mail_q **************************************** 
    pub fn rust_tos_prio_mail_q_create(
        prio_mail_q: *mut k_prio_mail_q_t,
        pool: *mut ::core::ffi::c_void,
        mail_cnt: size_t,
        mail_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_mail_q_destroy(prio_mail_q: *mut k_prio_mail_q_t) -> k_err_t;
    pub fn rust_tos_prio_mail_q_create_dyn(
        prio_mail_q: *mut k_prio_mail_q_t,
        mail_cnt: size_t,
        mail_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_mail_q_destroy_dyn(prio_mail_q: *mut k_prio_mail_q_t) -> k_err_t;
    pub fn rust_tos_prio_mail_q_flush(prio_mail_q: *mut k_prio_mail_q_t) -> k_err_t;
    pub fn rust_tos_prio_mail_q_pend(
        prio_mail_q: *mut k_prio_mail_q_t,
        mail_buf: *mut ::core::ffi::c_void,
        mail_size: *mut size_t,
        timeout: k_tick_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_mail_q_post(
        prio_mail_q: *mut k_prio_mail_q_t,
        mail_buf: *mut ::core::ffi::c_void,
        mail_size: size_t,
        prio: k_prio_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_mail_q_post_all(
        prio_mail_q: *mut k_prio_mail_q_t,
        mail_buf: *mut ::core::ffi::c_void,
        mail_size: size_t,
        prio: k_prio_t,
    ) -> k_err_t;
//***************************  tos_prio_mail_q **************************************** 

//***************************  tos ring_q **************************************** 
    pub fn rust_tos_ring_q_create(
        ring_q: *mut k_ring_q_t,
        pool: *mut ::core::ffi::c_void,
        item_cnt: size_t,
        item_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_ring_q_destroy(ring_q: *mut k_ring_q_t) -> k_err_t;
    pub fn rust_tos_ring_q_create_dyn(
        ring_q: *mut k_ring_q_t,
        item_cnt: size_t,
        item_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_ring_q_destroy_dyn(ring_q: *mut k_ring_q_t) -> k_err_t;
    pub fn rust_tos_ring_q_enqueue(
        ring_q: *mut k_ring_q_t,
        item: *mut ::core::ffi::c_void,
        item_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_ring_q_dequeue(
        ring_q: *mut k_ring_q_t,
        item: *mut ::core::ffi::c_void,
        item_size: *mut size_t,
    ) -> k_err_t;
    pub fn rust_tos_ring_q_flush(ring_q: *mut k_ring_q_t) -> k_err_t;
    pub fn rust_tos_ring_q_is_empty(ring_q: *mut k_ring_q_t) -> c_int;
    pub fn rust_tos_ring_q_is_full(ring_q: *mut k_ring_q_t) -> c_int;
//***************************  tos ring_q **************************************** 

//***************************  tos bin_heap **************************************** 
    pub fn rust_tos_bin_heap_create(
        bin_heap: *mut k_bin_heap_t,
        pool: *mut ::core::ffi::c_void,
        item_cnt: size_t,
        item_size: size_t,
        cmp: k_bin_heap_cmp,
    ) -> k_err_t;
    pub fn rust_tos_bin_heap_destroy(bin_heap: *mut k_bin_heap_t) -> k_err_t;
    pub fn rust_tos_bin_heap_create_dyn(
        bin_heap: *mut k_bin_heap_t,
        item_cnt: size_t,
        item_size: size_t,
        cmp: k_bin_heap_cmp,
    ) -> k_err_t;
    pub fn rust_tos_bin_heap_destroy_dyn(bin_heap: *mut k_bin_heap_t) -> k_err_t;
    pub fn rust_tos_bin_heap_push(
        bin_heap: *mut k_bin_heap_t,
        item: *mut ::core::ffi::c_void,
        item_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_bin_heap_pop(
        bin_heap: *mut k_bin_heap_t,
        item: *mut ::core::ffi::c_void,
        item_size: *mut size_t,
    ) -> k_err_t;
    pub fn rust_tos_bin_heap_flush(bin_heap: *mut k_bin_heap_t) -> k_err_t;
    pub fn rust_tos_bin_heap_is_empty(bin_heap: *mut k_bin_heap_t) -> c_int;
    pub fn rust_tos_bin_heap_is_full(bin_heap: *mut k_bin_heap_t) -> c_int;
//***************************  tos bin_heap **************************************** 

//***************************  tos prio_q **************************************** 
    pub fn rust_tos_prio_q_create(
        prio_q: *mut k_prio_q_t,
        mgr_array: *mut ::core::ffi::c_void,
        pool: *mut ::core::ffi::c_void,
        item_cnt: size_t,
        item_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_q_destroy(prio_q: *mut k_prio_q_t) -> k_err_t;
    pub fn rust_tos_prio_q_create_dyn(
        prio_q: *mut k_prio_q_t,
        item_cnt: size_t,
        item_size: size_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_q_destroy_dyn(prio_q: *mut k_prio_q_t) -> k_err_t;
    pub fn rust_tos_prio_q_enqueue(
        prio_q: *mut k_prio_q_t,
        item: *mut ::core::ffi::c_void,
        item_size: size_t,
        prio: k_prio_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_q_dequeue(
        prio_q: *mut k_prio_q_t,
        item: *mut ::core::ffi::c_void,
        item_size: *mut size_t,
        prio: *mut k_prio_t,
    ) -> k_err_t;
    pub fn rust_tos_prio_q_flush(prio_q: *mut k_prio_q_t) -> k_err_t;
    pub fn rust_tos_prio_q_is_empty(prio_q: *mut k_prio_q_t) -> c_int;
    pub fn rust_tos_prio_q_is_full(prio_q: *mut k_prio_q_t) -> c_int;

//***************************  tos prio_q **************************************** 

//***************************  tos timer **************************************** 
    pub fn rust_tos_timer_create(
        tmr: *mut k_timer_t,
        delay:*mut k_tick_t,
        period:*mut  k_tick_t,
        callback: k_timer_callback_t,
        cb_arg: *mut ::core::ffi::c_void,
        opt: k_opt_t,
    ) -> k_err_t;
    pub fn rust_tos_timer_destroy(tmr: *mut k_timer_t) -> k_err_t;
    pub fn rust_tos_timer_start(tmr: *mut k_timer_t) -> k_err_t;
    pub fn rust_tos_timer_stop(tmr: *mut k_timer_t) -> k_err_t;
    pub fn rust_tos_timer_delay_change(tmr: *mut k_timer_t, delay: k_tick_t) -> k_err_t;
    pub fn rust_tos_timer_period_change(tmr: *mut k_timer_t, period: k_tick_t) -> k_err_t;
    pub fn rust_timer_update();
    pub fn rust_timer_init() -> k_err_t;
    pub fn rust_timer_next_expires_get() -> k_tick_t;
//***************************  tos timer **************************************** 

//***************************  tos stopwatch **************************************** 
    pub fn rust_tos_stopwatch_create(stopwatch: *mut k_stopwatch_t) -> k_err_t;
    pub fn rust_tos_stopwatch_destroy(stopwatch: *mut k_stopwatch_t) -> k_err_t;
    pub fn rust_tos_stopwatch_countdown(stopwatch: *mut k_stopwatch_t, tick: k_tick_t) -> k_err_t;
    pub fn rust_tos_stopwatch_countdown_ms(stopwatch: *mut k_stopwatch_t, millisec: k_time_t)
        -> k_err_t;
    pub fn rust_tos_stopwatch_delay(tick: k_tick_t);
    pub fn rust_tos_stopwatch_delay_ms(millisec: k_time_t);
    pub fn rust_tos_stopwatch_remain(stopwatch: *mut k_stopwatch_t) -> k_tick_t;
    pub fn rust_tos_stopwatch_remain_ms(stopwatch: *mut k_stopwatch_t) -> k_time_t;
    pub fn rust_tos_stopwatch_is_expired(stopwatch: *mut k_stopwatch_t) -> c_int;
//***************************  tos stopwatch **************************************** 

//***************************  tos bitmap **************************************** 
    pub fn rust_tos_bitmap_create_empty(
        bitmap: *mut k_bitmap_t,
        bitmap_tbl: *mut k_bmtbl_t,
        bit_max: u32,
    ) -> k_err_t;
    pub fn rust_tos_bitmap_create_full(
        bitmap: *mut k_bitmap_t,
        bitmap_tbl: *mut k_bmtbl_t,
        bit_max: u32,
    ) -> k_err_t;
    pub fn rust_tos_bitmap_destroy(bitmap: *mut k_bitmap_t) -> k_err_t;
    pub fn rust_tos_bitmap_set(bitmap: *mut k_bitmap_t, bit: u32) -> k_err_t;
    pub fn rust_tos_bitmap_reset(bitmap: *mut k_bitmap_t, bit: u32) -> k_err_t;
    pub fn rust_tos_bitmap_is_set(bitmap: *mut k_bitmap_t, bit: u32) -> c_int;
    pub fn rust_tos_bitmap_is_reset(bitmap: *mut k_bitmap_t, bit: u32) -> c_int;
    pub fn rust_tos_bitmap_lsb(bitmap: *mut k_bitmap_t) -> c_int;
//***************************  tos bitmap **************************************** 

//***************************  tos pm management **************************************** 
    pub fn rust_tos_pm_cpu_lpwr_mode_set(cpu_lpwr_mode: k_cpu_lpwr_mode_t) -> k_err_t;
    pub fn rust_tos_pm_device_register(device: *mut k_pm_device_t) -> k_err_t;
    pub fn rust_tos_tickless_wkup_alarm_install(
        mode: k_cpu_lpwr_mode_t,
        wkup_alarm: *mut k_tickless_wkup_alarm_t,
    );
    pub fn rust_tos_tickless_wkup_alarm_init(mode: k_cpu_lpwr_mode_t) -> k_err_t;
//***************************  tos pm management ****************************************

    //tos_event
    pub fn rust_tos_event_create(event : *mut k_event_t , init_flag :  k_event_flag_t) -> k_err_en;
    pub fn rust_tos_event_destroy(event : *mut k_event_t) -> k_err_en;
    pub fn rust_tos_event_post(event: *mut k_event_t, flag: k_event_flag_t) -> k_err_t;
    pub fn rust_tos_event_post_keep(event: *mut k_event_t, flag: k_event_flag_t) -> k_err_t;
    pub fn rust_tos_event_pend(
        event: *mut k_event_t,
        flag_expect: k_event_flag_t,
        flag_match: *mut k_event_flag_t,
        timeout:*mut k_tick_t,
        opt_pend: k_opt_t,
    ) -> k_err_t;




    //tos_sem 
    pub fn rust_tos_sem_create_max(
        sem: *mut k_sem_t,
        init_count: k_sem_cnt_t,
        max_count: k_sem_cnt_t,
    ) -> k_err_t;

    pub fn rust_tos_sem_create(sem: *mut k_sem_t, init_count: k_sem_cnt_t) -> k_err_t;

    pub fn rust_tos_sem_create_max_dyn(
        sem: *mut *mut k_sem_t,
        init_count: k_sem_cnt_t,
        max_count: k_sem_cnt_t,
    ) -> k_err_t;

    pub fn rust_tos_sem_create_dyn(sem: *mut *mut k_sem_t, init_count: k_sem_cnt_t) -> k_err_t;

    pub fn rust_tos_sem_destroy(sem: *mut k_sem_t) -> k_err_t;

    pub fn rust_tos_sem_pend(sem: *mut k_sem_t, timeout:*mut  k_tick_t) -> k_err_t;

    pub fn rust_tos_sem_post(sem: *mut k_sem_t) -> k_err_t;

    pub fn rust_tos_sem_post_all(sem: *mut k_sem_t) -> k_err_t;




    //tos_chr_fifo
    pub fn rust_tos_chr_fifo_create(
        chr_fifo: *mut k_chr_fifo_t,
        buffer: *mut ::core::ffi::c_void,
        size: usize,
    ) -> k_err_t;

    pub fn rust_tos_chr_fifo_destroy(chr_fifo: *mut k_chr_fifo_t) -> k_err_t;

    pub fn rust_tos_chr_fifo_create_dyn(
        chr_fifo: *mut k_chr_fifo_t,
        fifo_size: usize,
    ) -> k_err_t;

    pub fn rust_tos_chr_fifo_destroy_dyn(chr_fifo: *mut k_chr_fifo_t) -> k_err_t;

    pub fn rust_tos_chr_fifo_push(chr_fifo: *mut k_chr_fifo_t, data: c_char)
        -> k_err_t;

    pub fn rust_tos_chr_fifo_push_stream(
        chr_fifo: *mut k_chr_fifo_t,
        stream: *mut u8,
        size: usize,
    ) -> i32;

    pub fn rust_tos_chr_fifo_pop(
        chr_fifo: *mut k_chr_fifo_t,
        out: *mut u8,
    ) -> k_err_t;

    pub fn rust_tos_chr_fifo_pop_stream(
        chr_fifo: *mut k_chr_fifo_t,
        buffer: *mut u8,
        size: usize,
    ) -> i32;

    pub fn rust_tos_chr_fifo_flush(chr_fifo: *mut k_chr_fifo_t) -> k_err_t;

    pub fn rust_tos_chr_fifo_is_empty(chr_fifo: *mut k_chr_fifo_t) -> i32;

    pub fn rust_tos_chr_fifo_is_full(chr_fifo: *mut k_chr_fifo_t) -> i32;


    pub fn rust_tos_systick_get() -> k_tick_t;
    pub fn rust_tos_systick_set(tick: k_tick_t);
    pub fn rust_tos_tick2millisec(tick: k_tick_t) -> k_time_t;
    pub fn rust_tos_millisec2tick(millisec: k_time_t) -> k_tick_t;
    pub fn rust_tos_sleep_ms(millisec: k_time_t) -> k_err_t;
    pub fn rust_tos_sleep_hmsm(
        hour: k_time_t,
        minute: k_time_t,
        second: k_time_t,
        millisec: k_time_t,
    ) -> k_err_t;


//********************************tos completion************************************ 
pub fn rust_tos_completion_create(completion: *mut k_completion_t) -> k_err_t;

pub fn rust_tos_completion_destroy(completion: *mut k_completion_t) -> k_err_t;

pub fn rust_tos_completion_pend_timed(completion: *mut k_completion_t, timeout: k_tick_t)
    -> k_err_t;

pub fn rust_tos_completion_pend(completion: *mut k_completion_t) -> k_err_t;

pub fn rust_tos_completion_post(completion: *mut k_completion_t) -> k_err_t;

pub fn rust_tos_completion_post_all(completion: *mut k_completion_t) -> k_err_t;

pub fn rust_tos_completion_reset(completion: *mut k_completion_t) -> k_err_t;

pub fn rust_tos_completion_is_done(completion: *mut k_completion_t) -> c_int;
//********************************tos completion************************************ 


//********************************tos countdownlatch************************************ 
pub fn rust_tos_countdownlatch_create(
    countdownlatch: *mut k_countdownlatch_t,
    count: k_countdownlatch_cnt_t,
) -> k_err_t;

pub fn rust_tos_countdownlatch_destroy(countdownlatch: *mut k_countdownlatch_t) -> k_err_t;

pub fn rust_tos_countdownlatch_pend_timed(
    countdownlatch: *mut k_countdownlatch_t,
    timeout: k_tick_t,
) -> k_err_t;

pub fn rust_tos_countdownlatch_pend(countdownlatch: *mut k_countdownlatch_t) -> k_err_t;

pub fn rust_tos_countdownlatch_post(countdownlatch: *mut k_countdownlatch_t) -> k_err_t;

pub fn rust_tos_countdownlatch_reset(
    countdownlatch: *mut k_countdownlatch_t,
    count: k_countdownlatch_cnt_t,
) -> k_err_t;
//********************************tos countdownlatch************************************ 

//********************************tos barrier************************************ 
pub fn rust_tos_barrier_create(barrier: *mut k_barrier_t, count: k_barrier_cnt_t) -> k_err_t;

pub fn rust_tos_barrier_destroy(barrier: *mut k_barrier_t) -> k_err_t;

pub fn rust_tos_barrier_pend(barrier: *mut k_barrier_t) -> k_err_t;

pub fn rust_tos_barrier_reset(barrier: *mut k_barrier_t, count: k_barrier_cnt_t) -> k_err_t;

//********************************tos barrier************************************ 

//********************************tos rwlock************************************ 
pub fn rust_tos_rwlock_create(rwlock: *mut k_rwlock_t) -> k_err_t;
pub fn rust_tos_rwlock_destroy(rwlock: *mut k_rwlock_t) -> k_err_t;
pub fn rust_tos_rwlock_rpend_timed(rwlock: *mut k_rwlock_t, timeout: k_tick_t) -> k_err_t;
pub fn rust_tos_rwlock_rpend(rwlock: *mut k_rwlock_t) -> k_err_t;
pub fn rust_tos_rwlock_rpend_try(rwlock: *mut k_rwlock_t) -> k_err_t;
pub fn rust_tos_rwlock_wpend_timed(rwlock: *mut k_rwlock_t, timeout: k_tick_t) -> k_err_t;
pub fn rust_tos_rwlock_wpend(rwlock: *mut k_rwlock_t) -> k_err_t;
pub fn rust_tos_rwlock_wpend_try(rwlock: *mut k_rwlock_t) -> k_err_t;
pub fn rust_tos_rwlock_rpost(rwlock: *mut k_rwlock_t) -> k_err_t;
pub fn rust_tos_rwlock_wpost(rwlock: *mut k_rwlock_t) -> k_err_t;
pub fn rust_tos_rwlock_post(rwlock: *mut k_rwlock_t) -> k_err_t;
//********************************tos rwlock************************************ 

//********************************tos rwlock************************************ 
pub fn rust_tos_msg_q_create(
    msg_q: *mut k_msg_q_t,
    pool: *mut ::core::ffi::c_void,
    msg_cnt: c_ulong,
) -> k_err_t;
pub fn rust_tos_msg_q_destroy(msg_q: *mut k_msg_q_t) -> k_err_t;
pub fn rust_tos_msg_q_create_dyn(msg_q: *mut k_msg_q_t, msg_cnt: c_ulong)
    -> k_err_t;
pub fn rust_tos_msg_q_destroy_dyn(msg_q: *mut k_msg_q_t) -> k_err_t;
pub fn rust_tos_msg_q_flush(msg_q: *mut k_msg_q_t) -> k_err_t;
pub fn rust_tos_msg_q_pend(
    msg_q: *mut k_msg_q_t,
    msg_ptr: *mut *mut ::core::ffi::c_void,
    timeout: k_tick_t,
) -> k_err_t;
pub fn rust_tos_msg_q_post(msg_q: *mut k_msg_q_t, msg_ptr: *mut ::core::ffi::c_void) -> k_err_t;
pub fn rust_tos_msg_q_post_all(msg_q: *mut k_msg_q_t, msg_ptr: *mut ::core::ffi::c_void) -> k_err_t;
//********************************tos rwlock************************************ 

//OLED
    pub fn rust_oled_print(x : u32, y : u32 ,msg: *const u8);
    pub fn rust_oled_init();
    pub fn rust_oled_clear();  


    pub fn rust_print_num(num : u32);
    pub fn rust_print_i32(num : i32);

    pub fn rust_print(msg: *const u8);

    pub fn rust_print_char(msg: *const u8);
    
    //wifi
    pub fn rust_wifi_init() -> c_int;
    pub fn rust_wifi_connect(ssid: *const u8, passwd: *const u8);
    
    pub fn rust_sleep(ms: u32);
    pub fn rust_mqtt_daemon() -> c_void;
   
}


